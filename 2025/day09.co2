part1(data) = solve(parse_lines(data));

solve(data) = max(map(pair_each(data), area_of_pair));

part2(data) = solve2(parse_lines(data));

solve2(points) = find_largest_2(points).area;

area_of_pair(p) =
    (1+abs(get(get(p,0),0)-get(get(p,1),0))) *
    (1+abs(get(get(p,0),1)-get(get(p,1),1))) ;

area_and_pair(p) = ({
    area: area_of_pair(p),
    p0: get(p,0),
    p1: get(p,1),
});

area_pairs(points) = map(pair_each(points), area_and_pair);

find_largest(points) = maxf(area_pairs(points), (o,l) -> by_area(o,l,points));

find_largest_2(points) = maxf(area_pairs(points), (o,l) -> non_intersecting_area(o,l,points));

by_area(obj,limit,points) = obj.area;

max(list) = reduce(list, (a,b) -> a+(b-a)*integer(a<b));

abs(x) = x*(1-2*integer(x<0));

parse_lines(x) = map(x, parse_line);

parse_line(x) = map(parse_split_tokens(x), to_integer);

parse_split_tokens(x) = split(x, ",");

to_integer(x) = integer(x);

non_intersecting_area(obj, maxarea, points) = {
    if (maxarea == void) {
        maxarea = 0;
    }
    if (obj.area < maxarea) {
        return obj.area; // early exit
    }
    local x0 = get(obj.p0,0);
    local y0 = get(obj.p0,1);
    local x1 = get(obj.p1,0);
    local y1 = get(obj.p1,1);
    local i=0;
    if (x0>x1) { i=x0; x0=x1; x1=i; };
    if (y0>y1) { i=y0; y0=y1; y1=i; };
    // check point inside rect
    local l=length(points);
    loop(i=0,i<l,i=i+1){
        local item = get(points,i);
        local x = get(item, 0);
        local y = get(item, 1);
        if (x <= x0) { continue; };
        if (y <= y0) { continue; };
        if (x >= x1) { continue; };
        if (y >= y1) { continue; };
        return 0;
    }
    // check intersecting edge
    local prev = get(points,l-1);
    local i=0;
    loop (i=0,i<l,i=i+1)
    {
        local next = get(points,i);
        local ex0 = get(prev,0);
        local ey0 = get(prev,1);
        local ex1 = get(next,0);
        local ey1 = get(next,1);
        local t = 0;
        if (ex0>ex1) { t=ex0; ex0=ex1; ex1=t; };
        if (ex0>ex1) { t=ex0; ex0=ex1; ex1=t; };
        if (ex1 <= x0) { prev = next; continue; };
        if (x1 <= ex0) { prev = next; continue; };
        if (ey1 <= y0) { prev = next; continue; };
        if (y1 <= ey0) { prev = next; continue; };
        return 0;
        prev = next;
    }
    return obj.area;
};

maxf(data, keyfn) = {
    local best = get(data,0);
    local bestval = keyfn(best);
    local i=0;
    local l=length(data);
    loop (i=1,i<l,i=i+1)
    {
        local item = get(data,i);
        local nextval = keyfn(item, bestval);
        if (nextval > bestval) {
            bestval = nextval;
            best = item;
        }
    }
    return best;
};

pair_each(data) = {
    local l = length(data);
    local i=0;
    local j=0;
    local result = array(l*(l-1)/2);
    local k=0;
    loop (i<l,i=i+1)
    {
        local ith=get(data,i);
        loop (j=i+1,j<l,j=j+1)
        {
            local jth=get(data,j);
            set(result,k,[ith,jth]);
            k=k+1;
        }
    }
    return result;
};

cases = [
    { fn: parse_lines, in: ["1,1","2,2"], out: [[1,1],[2,2]] },
    { fn: abs, in: -4, out: 4 },
    { fn: abs, in: 7, out: 7 },
    { fn: max, in: [1,4,9], out: 9 },
    { fn: area_of_pair, in: [[1,1],[3,3]], out: 9 },
    { fn: part1, in: ["1,1","1,1"], out: 1 },
    { fn: part1, in: ["1,1","2,2"], out: 4 },
    { fn: part1, in: ["1,1","-1,-1"], out: 9 },
    {
        fn: part2,
        // 1,1 #X# 3,1
        // 1,2 ##X
        // 2,3  ## 3,3
        in: ["1,1","3,1","3,3","2,3","2,2","1,2"],
        out: 3*2,
    },
];
